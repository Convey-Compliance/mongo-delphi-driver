unit TestMongoBson;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  SysUtils, TestFramework, MongoBson;

type
  // Test methods for class IBsonOID
  
  TestIBsonOID = class(TTestCase)
  private
    FIBsonOID: IBsonOID;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestSetValueAndGetValue;
    procedure TestAsString;
  end;
  // Test methods for class IBsonCodeWScope
  
  TestIBsonCodeWScope = class(TTestCase)
  private
    FIBsonCodeWScope: IBsonCodeWScope;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestsetAndGetCode;
    procedure TestsetAndGetScope;
  end;
  // Test methods for class IBsonRegex
  
  TestIBsonRegex = class(TTestCase)
  private
    FIBsonRegex: IBsonRegex;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestgetAndsetPattern;
    procedure TestgetAndsetOptions;
  end;
  // Test methods for class IBsonTimestamp
  
  TestIBsonTimestamp = class(TTestCase)
  private
    FIBsonTimestamp: IBsonTimestamp;
  private
    ANow: TDateTime;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestsetAndGetTime;
    procedure TestsetAndGetIncrement;
  end;
  // Test methods for class IBsonBinary
  
  TestIBsonBinary = class(TTestCase)
  private
    FIBsonBinary: IBsonBinary;
  private
    FData: array [0..255] of byte;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestgetLen;
    procedure TestsetAndGetData;
    procedure TestgetKindAndsetKind;
  end;
  // Test methods for class IBsonBuffer
  
  TestIBsonBuffer = class(TTestCase)
  private
    FIBsonBuffer: IBsonBuffer;
    procedure CheckObjectWithAppendedElements(Obj: IBson);
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestAppendStr;
    procedure TestAppendInteger;
    procedure TestAppendInt64;
    procedure TestAppendDouble;
    procedure TestappendDate;
    procedure TestAppendRegEx;
    procedure TestAppendTimeStamp;
    procedure TestAppendBsonBinary;
    procedure TestAppendIBson;
    procedure TestAppendVariant;
    procedure TestappendIntegerArray;
    procedure TestappendDoubleArray;
    procedure TestappendBooleanArray;
    procedure TestappendStringArray;
    procedure TestappendNull;
    procedure TestappendUndefined;
    procedure TestappendCode;
    procedure TestappendSymbol;
    procedure TestappendBinary;
    procedure TestappendCode_n;
    procedure TestAppendElementsAsArrayOfConst;
    procedure TestAppendElementsAsArraySubObjects;
    procedure TestAppendElementsAsVarRecArray;
    procedure TestAppendElementsAsArrayWithErrors;
    procedure TestAppendStr_n;
    procedure TestappendSymbol_n;
    procedure TeststartObject;
    procedure TeststartArray;
    procedure Testsize;
  end;
  // Test methods for class IBsonIterator
  
  TestIBsonIterator = class(TTestCase)
  private
    FIBsonIterator: IBsonIterator;
    b: IBson;
    bb: IBson;
    BoolArr: TBooleanArray;
    BsonOID: IBsonOID;
    BsonRegEx: IBsonRegex;
    DblArr: TDoubleArray;
    FTimestamp: IBsonTimestamp;
    IntArr: TIntegerArray;
    StrArr: TStringArray;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestGetAsInt64;
    procedure TestgetHandle;
    procedure TestgetBinary;
    procedure TestgetBooleanArray;
    procedure TestgetCodeWScope;
    procedure TestgetDoubleArray;
    procedure TestgetIntegerArray;
    procedure TestgetOID;
    procedure TestgetRegex;
    procedure TestgetStringArray;
    procedure TestgetTimestamp;
    procedure Testkey;
    procedure TestKind;
    procedure TestTryToReadPastEnd;
    procedure Testsubiterator;
    procedure TestValue;
  end;
  // Test methods for class IBson
  
  TestIBson = class(TTestCase)
  private
    FIBson: IBson;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure Testfind;
    procedure TestgetHandle;
    procedure Testiterator;
    procedure TestNewBsonCopy;
    procedure Testsize;
    procedure TestValue;
  end;

  TestBsonAPI = class(TTestCase)
  public
  published
    procedure Test_bson_set_oid_inc;
    procedure Test_bson_set_oid_fuzz;

  end;

implementation

uses
  Classes, Variants, MongoAPI;

const
  DELTA_DATE = 0.00009999;
  
procedure TestIBsonOID.SetUp;
begin
  FIBsonOID := NewBsonOID;
end;

procedure TestIBsonOID.TearDown;
begin
  FIBsonOID := nil;
  inherited;
end;

procedure TestIBsonOID.TestSetValueAndGetValue;
var
  AValue: TBsonOIDValue;
  i : integer;
begin
  for i := 0 to sizeof(AValue) - 1 do
    AValue[i] := i;
  FIBsonOID.setValue(AValue);
  for I := 0 to sizeof(AValue) - 1 do
    CheckEquals(i, FIBsonOID.getValue[i], 'All values of BSONID should be zero');
end;

procedure TestIBsonOID.TestAsString;
var
  ReturnValue: UTF8String;
  Val64 : Int64;
begin
  ReturnValue := FIBsonOID.AsString;
  HexToBin(PAnsiChar(ReturnValue), PAnsiChar(@Val64), sizeof(Val64));
  CheckNotEqualsString('', ReturnValue, 'Call to FIBsonOID should return value <> from ""');
end;

{ TestIBsonCodeWScope }

procedure TestIBsonCodeWScope.SetUp;
var
  NilBson : IBson;
begin
  NilBson := nil;
  FIBsonCodeWScope := NewBsonCodeWScope('', NilBson);
end;

procedure TestIBsonCodeWScope.TearDown;
begin
  FIBsonCodeWScope := nil;
  inherited;
end;

procedure TestIBsonCodeWScope.TestsetAndGetCode;
var
  ACode: UTF8String;
begin
  ACode := '123';
  FIBsonCodeWScope.setCode(ACode);
  CheckEqualsString('123', FIBsonCodeWScope.getCode, 'Call to FIBsonCodeWScope.GetCode should be equals to "123"');
end;

procedure TestIBsonCodeWScope.TestsetAndGetScope;
var
  AScope: IBson;
begin
  AScope := BSON(['ID', 1]);
  FIBsonCodeWScope.setScope(AScope);
  Check(AScope = FIBsonCodeWScope.getScope, 'Call to FIBsonCodeWScope.getScope should return value equals to AScope');
end;

{ TestIBsonRegex }

procedure TestIBsonRegex.SetUp;
begin
  FIBsonRegex := NewBsonRegex('123', '456');
end;

procedure TestIBsonRegex.TearDown;
begin
  FIBsonRegex := nil;
  inherited;
end;

procedure TestIBsonRegex.TestgetAndsetPattern;
var
  APattern: UTF8String;
begin
  CheckEqualsString('123', FIBsonRegex.getPattern, 'getPattern should return 123');
  APattern := '098';
  FIBsonRegex.setPattern(APattern);
  CheckEqualsString('098', FIBsonRegex.getPattern, 'call to getPattern after setting new value should return "098"');
end;

procedure TestIBsonRegex.TestgetAndsetOptions;
var
  AOptions: UTF8String;
begin
  CheckEqualsString('456', FIBsonRegex.getOptions, 'getOptions call should return "456"');
  AOptions := '789';
  FIBsonRegex.setOptions(AOptions);
  CheckEqualsString('789', FIBsonRegex.getOptions, 'Call to getOptions after setting options should return "789"');
end;

{ TestIBsonTimestamp }

procedure TestIBsonTimestamp.SetUp;
begin
  ANow := Now;
  FIBsonTimestamp := NewBsonTimestamp(ANow, 1);
end;

procedure TestIBsonTimestamp.TearDown;
begin
  FIBsonTimestamp := nil;
  inherited;
end;

procedure TestIBsonTimestamp.TestsetAndGetTime;
var
  ATime: TDateTime;
begin
  CheckEquals(ANow, FIBsonTimestamp.getTime, 'getTime should be equals to value set to ANow');
  ATime := 1.0;
  FIBsonTimestamp.setTime(ATime);
  CheckEquals(ATime, FIBsonTimestamp.getTime, 'getTime should return 1.0 after setting the value');
end;

procedure TestIBsonTimestamp.TestsetAndGetIncrement;
var
  AIncrement: Integer;
begin
  CheckEquals(1, FIBsonTimestamp.getIncrement, 'Initial value of increment should be equals to 1');
  AIncrement := 2;
  FIBsonTimestamp.setIncrement(AIncrement);
  CheckEquals(AIncrement, FIBsonTimestamp.getIncrement, 'New value of Increment should be equals to 2'); 
end;

{ TestIBsonBinary }

procedure TestIBsonBinary.SetUp;
var
  i : integer;
begin
  for I := low(FData) to high(FData) do
    FData[i] := i;
  FIBsonBinary := NewBsonBinary(@FData, sizeof(FData));
end;

procedure TestIBsonBinary.TearDown;
begin
  FIBsonBinary := nil;
  inherited;
end;

procedure TestIBsonBinary.TestgetLen;
var
  ReturnValue: Integer;
begin
  ReturnValue := FIBsonBinary.getLen;
  CheckEquals(sizeof(FData), ReturnValue, 'getLen should return sizeof(FData) local field');
end;

procedure TestIBsonBinary.TestsetAndGetData;
type
  PByteArray = ^TByteArray;
  TByteArray = array[0..255] of Byte;
var
  AData: Pointer;
  i : integer;
  ANewData : array[0..255] of Byte;
begin
  AData := FIBsonBinary.getData;
  for I := low(FData) to high(FData) do
    CheckEquals(i, PByteArray(AData)[i], 'Cached binary data on IBsonBinary doesn''t match with expected value');
  for I := low(ANewData) to high(ANewData) do
    ANewData[i] := sizeof(ANewData) - i;
  FIBsonBinary.setData(@ANewData, sizeof(ANewData));
  AData := FIBsonBinary.getData;
  for I := low(ANewData) to high(ANewData) do
    CheckEquals(byte(sizeof(ANewData) - i), PByteArray(AData)[i], 'Cached binary data on IBsonBinary doesn''t match with expected value');
end;

procedure TestIBsonBinary.TestgetKindAndsetKind;
var
  AKind: Integer;
begin
  CheckEquals(0, FIBsonBinary.getKind, 'Initial value of Kind should be zero');
  AKind := 1;
  FIBsonBinary.setKind(AKind);
  CheckEquals(1, FIBsonBinary.getKind, 'Value of Kind should be one');
end;

procedure TestIBsonBuffer.CheckObjectWithAppendedElements(Obj: IBson);
begin
  CheckEquals(1, Obj.value('int_fld'), 'int_fld doesn''t match expected value');
  CheckEquals(1, Obj.value('int_fld_wide'), 'int_fld_wide doesn''t match expected value');
  CheckEquals(1, Obj.value('int_fld_string'), 'int_fld_string doesn''t match expected value');
  CheckEquals(1, Obj.value('i'), 'i doesn''t match expected value');
  CheckEquals(1, Obj.value('w'), 'w doesn''t match expected value');
  CheckEquals(1, Obj.value('int_fld_pchar'), 'int_fld_pchar doesn''t match expected value');
  {$IFDEF DELPHI2009}
  CheckEquals(1, Obj.value('int_fld_pwidechar'), 'int_fld_pwidechar doesn''t match expected value');
  CheckEquals(1, Obj.value('int_fld_unicodestring'), 'int_fld_unicodestring doesn''t match expected value');
  {$ENDIF}
  Check(Boolean(Obj.value('bool_fld')), 'bool_fld doesn''t match expected value');
  CheckEqualsString('a', Obj.value('ansichar_fld'), 'ansichar_fld doesn''t match expected value');
  CheckEqualsString(FloatToStr(1.1), FloatToStr(Obj.value('extended_fld')), 'extended_fld doesn''t match expected value');
  CheckEqualsString('pansichar_val', Obj.value('pansichar_fld'), 'pansichar_fld doesn''t match expected value');
  CheckEqualsString('v', Obj.value('widechar_fld'), 'widechar_fld doesn''t match expected value');
  {$IFDEF DELPHI2009}
  CheckEqualsString('pwidechar_val', Obj.value('pwidechar_fld'), 'pwidechar_fld doesn''t match expected value');
  {$ENDIF}
  CheckEqualsString('ansistring_val', Obj.value('ansistring_fld'), 'ansistring_fld doesn''t match expected value');
  CheckEqualsString('string_val', Obj.value('string_fld'), 'string_fld doesn''t match expected value');
  CheckEqualsString(FloatToStr(1.2), FloatToStr(Obj.value('currency_fld')), 'currency_fld doesn''t match expected value');
  CheckEquals(1234, Obj.value('variant_fld'), 'variant_fld doesn''t match expected value');
  CheckEqualsString('widestring_val', Obj.value('widestring_fld'), 'widestring_fld doesn''t match expected value');
  {$IFDEF DELPHI2009}
  CheckEquals(10000000000, Obj.value('int64_fld'), 'int64_fld doesn''t match expected value');
  CheckEqualsString('unicode_val', Obj.value('unicode_fld'), 'unicode_fld doesn''t match expected value');
  {$ENDIF}
end;

{ TestIBsonBuffer }

procedure TestIBsonBuffer.SetUp;
begin
  FIBsonBuffer := NewBsonBuffer;
end;

procedure TestIBsonBuffer.TearDown;
begin
  FIBsonBuffer := nil;
  inherited;
end;

procedure TestIBsonBuffer.TestAppendStr;
var
  ReturnValue: Boolean;
  Value: UTF8String;
  Name: UTF8String;
  b : IBson;
begin
  Name := 'STRFLD';
  Value := 'STRVAL';
  ReturnValue := FIBsonBuffer.AppendStr(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True');
  b := FIBsonBuffer.finish;
  CheckEqualsString('STRVAL', b.Value('STRFLD'), 'field on BSon object doesn''t match expected value');
end;

procedure TestIBsonBuffer.TestAppendInteger;
var
  ReturnValue: Boolean;
  Value: Integer;
  Name: UTF8String;
  b : IBson;
begin
  Name := 'INTFLD';
  Value := 100;
  ReturnValue := FIBsonBuffer.Append(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True');
  b := FIBsonBuffer.finish;
  CheckEquals(100, b.Value('INTFLD'), 'field on BSon object doesn''t match expected value');
end;

procedure TestIBsonBuffer.TestAppendInt64;
var
  ReturnValue: Boolean;
  Value: Int64;
  Name: UTF8String;
  b : IBson;
begin
  Name := 'INT64FLD';
  Value := Int64(MaxInt) * 10;
  ReturnValue := FIBsonBuffer.Append(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True');
  b := FIBsonBuffer.finish;
  CheckEquals(Int64(MaxInt) * 10, b.ValueAsInt64('INT64FLD'), 'field on BSon object doesn''t match expected value');
end;

procedure TestIBsonBuffer.TestAppendDouble;
var
  ReturnValue: Boolean;
  Value: Double;
  Name: UTF8String;
  b : IBson;
begin
  Name := 'DBLFLD';
  Value := 100.5;
  ReturnValue := FIBsonBuffer.Append(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True');
  b := FIBsonBuffer.finish;
  CheckEquals(100.5, b.Value('DBLFLD'), 'field on BSon object doesn''t match expected value');
end;

procedure TestIBsonBuffer.TestappendDate;
var
  ReturnValue: Boolean;
  Value: TDateTime;
  Name: UTF8String;
  b : IBson;
begin
  Name := 'DATEFLD';
  Value := Now;
  ReturnValue := FIBsonBuffer.appendDate(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True');
  b := FIBsonBuffer.finish;
  CheckEquals(Value, b.Value('DATEFLD'), DELTA_DATE, 'field on BSon object doesn''t match expected value');
end;

procedure TestIBsonBuffer.TestAppendRegEx;
var
  ReturnValue: Boolean;
  Value: IBsonRegex;
  Name: UTF8String;
  b : IBson;
  i : IBsonIterator;
begin
  Name := 'REGEXFLD';
  Value := NewBsonRegex('123', '456');
  ReturnValue := FIBsonBuffer.Append(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True');
  b := FIBsonBuffer.finish;
  i := b.find(Name);
  Check(i <> nil, 'Iterator should be <> nil');
  CheckEqualsString('123', i.getRegex.getPattern, 'Pattern should be equals to "123"');
  CheckEqualsString('456', i.getRegex.getOptions, 'Pattern should be equals to "456"');
end;

procedure TestIBsonBuffer.TestAppendTimeStamp;
var
  ReturnValue: Boolean;
  Value: IBsonTimestamp;
  Name: UTF8String;
  b : IBson;
  i : IBsonIterator;
begin
  Name := 'TSFLD';
  Value := NewBsonTimestamp(Now, 1);
  ReturnValue := FIBsonBuffer.Append(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True');
  b := FIBsonBuffer.finish;
  i := b.find(Name);
  Check(i <> nil, 'Iterator should be <> nil');
  CheckEquals(Value.getTime, i.getTimestamp.getTime, DELTA_DATE, 'Time should be equals to Value.getTime');
  CheckEquals(Value.getIncrement, i.getTimestamp.getIncrement, DELTA_DATE, 'Increment should be equals to Value.getIncrement');
end;

procedure TestIBsonBuffer.TestAppendBsonBinary;
type
  PData = ^TData;
  TData = array [0..255] of Byte;
var
  ReturnValue: Boolean;
  Value: IBsonBinary;
  Name: UTF8String;
  b : IBson;
  i : IBsonIterator;
  Data : array [0..255] of Byte;
  ii : integer;
begin
  for ii := 0 to sizeof(Data) - 1 do
    Data[ii] := ii;
  Name := 'BSONBINFLD';
  Value := NewBsonBinary(@Data, sizeof(Data));
  ReturnValue := FIBsonBuffer.Append(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True');
  b := FIBsonBuffer.finish;
  i := b.find(Name);
  Check(i <> nil, 'Iterator should be <> nil');
  for ii := 0 to i.getBinary.getLen - 1 do
    CheckEquals(Data[ii], PData(i.getBinary.getData)[ii], 'Data from BsonBinary object doesn''t match');
end;

procedure TestIBsonBuffer.TestAppendIBson;
var
  ReturnValue: Boolean;
  Value: IBson;
  Name: UTF8String;
  b : IBson;
  i : IBsonIterator;
begin
  Name := 'BSFLD';
  Value := BSON(['ID', 1]);
  ReturnValue := FIBsonBuffer.Append(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True');
  b := FIBsonBuffer.finish;
  i := b.find(Name);
  Check(i <> nil, 'Iterator should be <> nil');
  CheckEquals(1, i.subiterator.Value, 'Value doesn''t match');
end;

procedure TestIBsonBuffer.TestAppendVariant;
var
  ReturnValue: Boolean;
  Value : Variant;
  Name: UTF8String;
  b : IBson;
  var_single : Single;
  var_double : Double;
  var_currency : Currency;
  {$IFDEF DELPHI2009}
  v_int64 : Int64;
  {$ENDIF}
  v_longword : LongWord;
begin
  Name := 'VARIANTFLD_NULL';
  Value := Null;
  ReturnValue := FIBsonBuffer.AppendVariant(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True inserting VARIANTFLD_NULL');

  Name := 'VARIANTFLD_BYTE';
  Value := Byte(1);
  ReturnValue := FIBsonBuffer.AppendVariant(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True inserting VARIANTFLD_BYTE');

  Name := 'VARIANTFLD_WORD';
  Value := Word(1234);
  ReturnValue := FIBsonBuffer.AppendVariant(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True inserting VARIANTFLD_WORD');

  Name := 'VARIANTFLD_SMALL';
  Value := Smallint(12);
  ReturnValue := FIBsonBuffer.AppendVariant(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True inserting VARIANTFLD_SMALL');

  Name := 'VARIANTFLD_SHORT';
  Value := Shortint(-12);
  ReturnValue := FIBsonBuffer.AppendVariant(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True inserting VARIANTFLD_SHORT');

  Name := 'VARIANTFLD_INT';
  Value := integer(123);
  ReturnValue := FIBsonBuffer.AppendVariant(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True inserting VARIANTFLD_INT');

  Name := 'VARIANTFLD_LONGWORD';
  v_longword := 1000000000;
  Value := v_longword;
  ReturnValue := FIBsonBuffer.AppendVariant(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True inserting VARIANTFLD_LONGWORD');

  Name := 'VARIANTFLD_SINGLE';
  var_single := 1000.1;
  ReturnValue := FIBsonBuffer.AppendVariant(Name, var_single);
  Check(ReturnValue, 'ReturnValue should be True inserting VARIANTFLD_SINGLE');

  Name := 'VARIANTFLD_DOUBLE';
  var_double := 1000.2;
  ReturnValue := FIBsonBuffer.AppendVariant(Name, var_double);
  Check(ReturnValue, 'ReturnValue should be True inserting VARIANTFLD_DOUBLE');

  Name := 'VARIANTFLD_CURRENCY';
  var_currency := 1000.3;
  ReturnValue := FIBsonBuffer.AppendVariant(Name, var_currency);
  Check(ReturnValue, 'ReturnValue should be True inserting VARIANTFLD_CURRENCY');

  Name := 'VARIANTFLD_DATE';
  Value := StrToDateTime('1/1/2013');
  ReturnValue := FIBsonBuffer.AppendVariant(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True inserting VARIANTFLD_DATE');

  {$IFDEF DELPHI2009}
  Name := 'VARIANTFLD_INT64';
  v_int64 := 10000000000;
  Value := v_int64;
  ReturnValue := FIBsonBuffer.AppendVariant(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True inserting VARIANTFLD_INT64');
  {$ENDIF}

  Name := 'VARIANTFLD_BOOL';
  Value := True;
  ReturnValue := FIBsonBuffer.AppendVariant(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True inserting VARIANTFLD_BOOL');

  Name := 'VARIANTFLD_STR';
  Value := 'HOLA';
  ReturnValue := FIBsonBuffer.AppendVariant(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True inserting VARIANTFLD_STR');

  {$IFDEF DELPHI2009}
  Name := 'VARIANTFLD_USTR';
  Value := UnicodeString('HOLA');
  ReturnValue := FIBsonBuffer.AppendVariant(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True inserting VARIANTFLD_USTR');
  {$ENDIF}

  b := FIBsonBuffer.finish;

  Check(VarIsNull(b.Value('VARIANTFLD_NULL')), 'Expected null bson. Value doesn''t match');
  CheckEquals(1, integer(b.Value('VARIANTFLD_BYTE')), 'Value doesn''t match');
  CheckEquals(1234, integer(b.Value('VARIANTFLD_WORD')), 'Value doesn''t match');
  CheckEquals(12, integer(b.Value('VARIANTFLD_SMALL')), 'Value doesn''t match');
  CheckEquals(-12, integer(b.Value('VARIANTFLD_SHORT')), 'Value doesn''t match');
  CheckEquals(123, integer(b.Value('VARIANTFLD_INT')), 'Value doesn''t match');
  CheckEqualsString(Format('%8.1f', [1000.1]), Format('%8.1f', [Single(b.Value('VARIANTFLD_SINGLE'))]), 'Value doesn''t match');
  CheckEqualsString(Format('%8.1f', [1000.2]), Format('%8.1f', [Double(b.Value('VARIANTFLD_DOUBLE'))]), 'Value doesn''t match');
  CheckEqualsString(Format('%8.1f', [1000.3]), Format('%8.1f', [Currency(b.Value('VARIANTFLD_CURRENCY'))]), 'Value doesn''t match');
  CheckEqualsString('1/1/2013', DateTimeToStr(b.Value('VARIANTFLD_DATE')), 'Value doesn''t match');
  {$IFDEF DELPHI2009}
  CheckEquals(10000000000, Int64(b.Value('VARIANTFLD_INT64')), 'Value doesn''t match');
  {$ENDIF}
  CheckEquals(1000000000, LongWord(b.Value('VARIANTFLD_LONGWORD')), 'Value doesn''t match');
  Check(b.Value('VARIANTFLD_BOOL'), 'Value doesn''t match for VARIANTFLD_BOOL');
  CheckEqualsString('HOLA', b.Value('VARIANTFLD_STR'), 'Value doesn''t match');
  {$IFDEF DELPHI2009}
  CheckEqualsString('HOLA', b.Value('VARIANTFLD_USTR'), 'Value doesn''t match');
  {$ENDIF}
end;

procedure TestIBsonBuffer.TestappendIntegerArray;
var
  ReturnValue: Boolean;
  Value: TIntegerArray;
  Name: UTF8String;
  i : integer;
  it : IBsonIterator;
  b : IBson;
begin
  Name := 'INTARRFLD';
  SetLength(Value, 10);
  for I := low(Value) to high(Value) do
    Value[i] := i;
  ReturnValue := FIBsonBuffer.appendArray(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True');
  b := FIBsonBuffer.finish;
  it := b.iterator;
  it.Next;
  CheckEquals(length(Value), length(it.getIntegerArray), 'Array sizes don''t match');
  for I := low(it.getIntegerArray) to high(it.getIntegerArray) do
    CheckEquals(Value[i], it.getIntegerArray[i], 'Items on Integer array don''t match');   
end;

procedure TestIBsonBuffer.TestappendDoubleArray;
var
  ReturnValue: Boolean;
  Value: TDoubleArray;
  Name: UTF8String;
  i : integer;
  it : IBsonIterator;
  b : IBson;
begin
  Name := 'DBLARRFLD';
  SetLength(Value, 10);
  for I := low(Value) to high(Value) do
    Value[i] := i + 0.2;
  ReturnValue := FIBsonBuffer.appendArray(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True');
  b := FIBsonBuffer.finish;
  it := b.iterator;
  it.Next;
  CheckEquals(length(Value), length(it.getDoubleArray), 'Array sizes don''t match');
  for I := low(it.getDoubleArray) to high(it.getDoubleArray) do
    CheckEquals(Value[i], it.getDoubleArray[i], 'Items on Double array don''t match');
end;

procedure TestIBsonBuffer.TestappendBooleanArray;
var
  ReturnValue: Boolean;
  Value: TBooleanArray;
  Name: UTF8String;
  i : integer;
  it : IBsonIterator;
  b : IBson;
  BoolArrayResult : TBooleanArray;
begin
  Name := 'BOOLARRFLD';
  SetLength(Value, 10);
  for I := low(Value) to high(Value) do
    Value[i] := i mod 2 = 1;
  ReturnValue := FIBsonBuffer.appendArray(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True');
  b := FIBsonBuffer.finish;
  it := b.iterator;
  it.Next;
  BoolArrayResult := it.getBooleanArray;
  CheckEquals(length(Value), length(BoolArrayResult), 'Array sizes don''t match');
  for I := low(BoolArrayResult) to high(BoolArrayResult) do
    CheckEquals(Value[i], BoolArrayResult[i], 'Items on Boolean array don''t match');
end;

procedure TestIBsonBuffer.TestappendStringArray;
var
  ReturnValue: Boolean;
  Value: TStringArray;
  Name: UTF8String;
  i : integer;
  it : IBsonIterator;
  b : IBson;
begin
  Name := 'BOOLARRFLD';
  SetLength(Value, 10);
  for I := low(Value) to high(Value) do
    Value[i] := IntToStr(i);
  ReturnValue := FIBsonBuffer.appendArray(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True');
  b := FIBsonBuffer.finish;
  it := b.iterator;
  it.Next;
  CheckEquals(length(Value), length(it.getStringArray), 'Array sizes don''t match');
  for I := low(it.getStringArray) to high(it.getStringArray) do
    CheckEqualsString(Value[i], it.getStringArray[i], 'Items on UTF8String array don''t match');
end;

procedure TestIBsonBuffer.TestappendNull;
var
  ReturnValue: Boolean;
  Name: UTF8String;
  v : Variant;
  b : IBson;
begin
  Name := 'NULLFLD';
  ReturnValue := FIBsonBuffer.appendNull(Name);
  Check(ReturnValue, 'ReturnValue should be True');
  b := FIBsonBuffer.finish;
  v := b.Value(Name);
  Check(VarIsNull(v), 'Field should be NULL');
end;

procedure TestIBsonBuffer.TestappendUndefined;
var
  ReturnValue: Boolean;
  Name: UTF8String;
  v : Variant;
  b : IBson;
begin
  Name := 'EMPTYFLD';
  ReturnValue := FIBsonBuffer.appendUndefined(Name);
  Check(ReturnValue, 'ReturnValue should be True');
  b := FIBsonBuffer.finish;
  v := b.Value(Name);
  Check(VarIsEmpty(v), 'Field should be EMPTY');
end;

procedure TestIBsonBuffer.TestappendCode;
var
  ReturnValue: Boolean;
  Value: UTF8String;
  Name: UTF8String;
  b : IBson;
  i : IBsonIterator;
begin
  Name := 'CODEFLD';
  Value := '123456';
  ReturnValue := FIBsonBuffer.appendCode(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True');
  b := FIBsonBuffer.finish;
  i := b.iterator;
  CheckEqualsString(Value, i.getCodeWScope.getCode, 'Code should be equals to "123456"');
end;

procedure TestIBsonBuffer.TestappendSymbol;
var
  ReturnValue: Boolean;
  Value: UTF8String;
  Name: UTF8String;
  b : IBson;
begin
  Name := 'CODEFLD';
  Value := 'SymbolTest';
  ReturnValue := FIBsonBuffer.appendSymbol(Name, Value);
  Check(ReturnValue, 'ReturnValue should be True');
  b := FIBsonBuffer.finish;
  CheckEqualsString(Value, b.Value(Name), 'Symbol value doesn''t match');
end;

procedure TestIBsonBuffer.TestappendBinary;
type
  PData = ^TData;
  TData = array [0..15] of Byte;
const
  AData : TData = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
var
  ReturnValue: Boolean;
  Length: Integer;
  Data: Pointer;
  Kind: Integer;
  Name: UTF8String;
  b : IBson;
  i : integer;
  it : IBsonIterator;
begin
  Name := 'BINFLD';
  Length := sizeof(AData);
  Data := @AData;
  Kind := 0;
  ReturnValue := FIBsonBuffer.appendBinary(Name, Kind, Data, Length);
  Check(ReturnValue, 'ReturnValue should be True');
  b := FIBsonBuffer.finish;
  it := b.iterator;
  for i := low(AData) to high(AData) do
    CheckEquals(AData[i], PData(it.getBinary.getData)^[i], 'Binary data doesn''t match');
end;

procedure TestIBsonBuffer.TestappendCode_n;
var
  ReturnValue: Boolean;
  Value: UTF8String;
  Name: UTF8String;
  b : IBson;
  i : IBsonIterator;
begin
  Name := 'CODEFLD';
  Value := '123';
  ReturnValue := FIBsonBuffer.appendCode_n(Name, Value, 3);
  Check(ReturnValue, 'ReturnValue should be True');
  b := FIBsonBuffer.finish;
  i := b.iterator;
  CheckEqualsString('123', i.getCodeWScope.getCode, 'Code should be equals to "123"');
end;

procedure TestIBsonBuffer.TestAppendElementsAsArrayOfConst;
var
  Obj : IBson;
  variant_val : Variant;
  val_extended : Extended;
  val_currency : Currency;
begin
  variant_val := 1234;
  val_extended := 1.1;
  val_currency := 1.2;
  Check(FIBsonBuffer.appendElementsAsArray(['int_fld', 1,
                                            WideString('int_fld_wide'), 1,
                                            ShortString('int_fld_string'), 1,
                                            AnsiChar('i'), 1,
                                            WideChar('w'), 1,
                                            PAnsiChar('int_fld_pchar'), 1,
                                            {$IFDEF DELPHI2009}
                                            PWideChar('int_fld_pwidechar'), 1,
                                            UnicodeString('int_fld_unicodestring'), 1,
                                            {$ENDIF}
                                            'bool_fld', True,
                                            'ansichar_fld', AnsiChar('a'),
                                            'extended_fld', val_extended,
                                            'pansichar_fld', PAnsiChar('pansichar_val'),
                                            'widechar_fld', WideChar('v'),
                                            {$IFDEF DELPHI2009}
                                            'pwidechar_fld', PWideChar('pwidechar_val'),
                                            {$ENDIF}
                                            'ansistring_fld', UTF8String('ansistring_val'),
                                            'string_fld', ShortString('string_val'),
                                            'currency_fld', val_currency,
                                            'variant_fld', variant_val,
                                            'widestring_fld', WideString('widestring_val'),
                                            'int64_fld', Int64(10000000000)
                                            {$IFDEF DELPHI2009}
                                            , 'unicode_fld', UnicodeString('unicode_val') {$ENDIF}]), 'call to appendElementsAsArray should return true');
  Obj := FIBsonBuffer.finish;
  CheckObjectWithAppendedElements(Obj);
end;

procedure TestIBsonBuffer.TestAppendElementsAsArraySubObjects;
var
  Obj : IBson;
  it : IBsonIterator;
begin
  Check(FIBsonBuffer.appendElementsAsArray(['int', 1, 'sub_obj',
                                            '{', 'str', 'string',
                                                 'int_2', 2, '}']), 'Call t appendElementsAsArray failed');
  Obj := FIBsonBuffer.finish;
  CheckEquals(1, Obj.value('int'), 'Value of int doesn''t match');
  it := Obj.find('sub_obj');
  Check(it <> nil, 'iterator sub_obj should be <> nil');
  it := it.subiterator;
  Check(it.next, 'first call to it.next should return true');
  Check(it <> nil, 'subiterator of sub_obj should be <> nil');
  CheckEqualsString('str', it.key, 'first key value of subobject doesn''t match');
  CheckEqualsString('string', it.value, 'value of key subobject attribute doesn''t match');
  Check(it.next, 'call to it.next should return value <> nil');
  CheckEqualsString('int_2', it.key, 'first key value of subobject doesn''t match');
  CheckEquals(2, it.value, 'value of key subobject attribute doesn''t match');
end;

procedure TestIBsonBuffer.TestAppendElementsAsVarRecArray;
const
  int_fld : UTF8String = 'int_fld';
  int_fld_wide : WideString = 'int_fld_wide';
  int_fld_string : ShortString = 'int_fld_string';
  int_fld_char : AnsiChar = 'i';
  int_fld_WideChar : WideChar = 'w';
  int_fld_pchar : PAnsiChar = 'int_fld_pchar';
  int_fld_PWideChar : PWideChar = 'int_fld_pwidechar';
  {$IFDEF DELPHI2009}
  int_fld_UnicodeString : UnicodeString = 'int_fld_unicodestring';
  {$ENDIF}
  bool_fld : UTF8String = 'bool_fld';
  ansichar_fld : UTF8String = 'ansichar_fld';
  extended_fld : UTF8String = 'extended_fld';
  extended_value : Extended = 1.1;
  pansichar_fld : UTF8String = 'pansichar_fld';
  pansichar_val : PAnsiChar = 'pansichar_val';
  widechar_fld : UTF8String = 'widechar_fld';
  widechar_val : WideChar = 'v';
  pwidechar_fld : UTF8String = 'pwidechar_fld';
  pwidechar_val : PWideChar = 'pwidechar_val';
  ansistring_fld : UTF8String = 'ansistring_fld';
  ansistring_val : UTF8String = 'ansistring_val';
  string_fld : UTF8String = 'string_fld';
  string_val : ShortString = 'string_val';
  currency_fld : UTF8String = 'currency_fld';
  currency_val : currency = 1.2;
  variant_fld : UTF8String = 'variant_fld';
  widestring_fld : UTF8String = 'widestring_fld';
  widestring_val : WideString = 'widestring_val';
  int64_fld : UTF8String = 'int64_fld';
  int64_val : Int64 = 10000000000;
  unicode_fld : UTF8String = 'unicode_fld';
  {$IFDEF DELPHI2009}
  unicode_val : UnicodeString = 'unicode_val';
  {$ENDIF}
var
  Def : TVarRecArray;
  Obj : IBson;
  variant_val : Variant;
  procedure PrepareDifferentFieldTypeTests;
  begin
    // Field as UTF8String
    Def[0].VType := vtAnsiString;
    Def[0].VAnsiString := pointer(int_fld);
    Def[1].VType := vtInteger;
    Def[1].VInteger := 1;
    // Field as WideString
    Def[2].VType := vtWideString;
    Def[2].VWideString := pointer(int_fld_wide);
    Def[3].VType := vtInteger;
    Def[3].VInteger := 1;
    // Field as ShortString
    Def[4].VType := vtString;
    Def[4].VString := @int_fld_string;
    Def[5].VType := vtInteger;
    Def[5].VInteger := 1;
    // Field as Char
    Def[6].VType := vtChar;
    Def[6].VChar := int_fld_char;
    Def[7].VType := vtInteger;
    Def[7].VInteger := 1;
    // Field as WideChar
    Def[8].VType := vtWideChar;
    Def[8].VWideChar := int_fld_widechar;
    Def[9].VType := vtInteger;
    Def[9].VInteger := 1;
    // Field as PAnsiChar
    Def[10].VType := vtPChar;
    Def[10].VPChar := int_fld_pchar;
    Def[11].VType := vtInteger;
    Def[11].VInteger := 1;
    // Field as PWideChar
    Def[12].VType := vtPWideChar;
    Def[12].VPWideChar := int_fld_PWideChar;
    Def[13].VType := vtInteger;
    Def[13].VInteger := 1;
    {$IFDEF DELPHI2009}
    // Field as UnicodeString
    Def[14].VType := vtUnicodeString;
    Def[14].VUnicodeString := pointer(int_fld_UnicodeString);
    Def[15].VType := vtInteger;
    Def[15].VInteger := 1;
    {$ELSE}
    Def[14].VType := vtWideString;
    Def[14].VWideString := pointer(int_fld_wide);
    Def[15].VType := vtInteger;
    Def[15].VInteger := 1;
    {$ENDIF}
  end;
  procedure PrepareDifferentValueTypesTests;
  begin
    // Value as Boolean
    Def[16].VType := vtAnsiString;
    Def[16].VAnsiString := pointer(bool_fld);
    Def[17].VType := vtBoolean;
    Def[17].VBoolean := True;
    // Value as AnsiChar
    Def[18].VType := vtAnsiString;
    Def[18].VAnsiString := pointer(ansichar_fld);
    Def[19].VType := vtChar;
    Def[19].VChar := 'a';
    // Value as Extended
    Def[20].VType := vtAnsiString;
    Def[20].VAnsiString := pointer(extended_fld);
    Def[21].VType := vtExtended;
    Def[21].VExtended := @extended_value;
    // Value as PChar
    Def[22].VType := vtAnsiString;
    Def[22].VAnsiString := pointer(pansichar_fld);
    Def[23].VType := vtPChar;
    Def[23].VPChar := pansichar_val;
    // Value as WideChar
    Def[24].VType := vtAnsiString;
    Def[24].VAnsiString := pointer(widechar_fld);
    Def[25].VType := vtWideChar;
    Def[25].VWideChar := widechar_val;
    // Value as PWideChar
    Def[26].VType := vtAnsiString;
    Def[26].VAnsiString := pointer(pwidechar_fld);
    Def[27].VType := vtPWideChar;
    Def[27].VPWideChar := pwidechar_val;
    // Value as UTF8String
    Def[28].VType := vtAnsiString;
    Def[28].VAnsiString := pointer(ansistring_fld);
    Def[29].VType := vtAnsiString;
    Def[29].VAnsiString := pointer(ansistring_val);
    // Value as shortstring
    Def[30].VType := vtAnsiString;
    Def[30].VAnsiString := pointer(string_fld);
    Def[31].VType := vtString;
    Def[31].VString := @string_val;
    // Value as currency
    Def[32].VType := vtAnsiString;
    Def[32].VAnsiString := pointer(currency_fld);
    Def[33].VType := vtCurrency;
    Def[33].VCurrency := @currency_val;
    // Value as variant
    Def[34].VType := vtAnsiString;
    Def[34].VAnsiString := pointer(variant_fld);
    Def[35].VType := vtVariant;
    Def[35].VVariant := @variant_val;
    // Value as Widestring
    Def[36].VType := vtAnsiString;
    Def[36].VAnsiString := pointer(widestring_fld);
    Def[37].VType := vtWideString;
    Def[37].VWideString := pointer(widestring_val);
    // Value as Int64
    Def[38].VType := vtAnsiString;
    Def[38].VAnsiString := pointer(int64_fld);
    Def[39].VType := vtInt64;
    Def[39].VInt64 := @int64_val;
    {$IFDEF DELPHI2009}
    // Value as UnicodeString
    Def[40].VType := vtAnsiString;
    Def[40].VAnsiString := pointer(unicode_fld);
    Def[41].VType := vtUnicodeString;
    Def[41].VInt64 := pointer(unicode_val);
    {$ENDIF}
  end;
begin
  variant_val := 1234;
  SetLength(Def, {$IFDEF DELPHI2009} 42 {$ELSE} 40 {$ENDIF});
  PrepareDifferentFieldTypeTests;
  PrepareDifferentValueTypesTests;
  Check(FIBsonBuffer.appendElementsAsArray(Def), 'call to appendElementsAsArray should return true');
  Obj := FIBsonBuffer.finish;
  CheckObjectWithAppendedElements(Obj);
end;

procedure TestIBsonBuffer.TestAppendElementsAsArrayWithErrors;
const
  fld : UTF8String = 'fld';
  int_val : Integer = 0;
var
  Def : TVarRecArray;
begin
  SetLength(Def, 2);
  Def[0].VType := vtInteger;
  Def[0].VAnsiString := @int_val;
  Def[1].VType := vtAnsiString;
  Def[1].VAnsiString := @fld;
  try
    FIBsonBuffer.appendElementsAsArray(Def);
    Fail('call to appendElementsAsArray should have raise exception');
  except
    on E : Exception do Check(pos('def element should be a string', E.Message) > 0, 'appendElementsAsArray should have raised exception. error: ' + E.Message);
  end;

  SetLength(Def, 2);
  Def[0].VType := vtAnsiString;
  Def[0].VAnsiString := @fld;
  Def[1].VType := vtInterface;
  Def[1].VInterface := nil;
  try
    FIBsonBuffer.appendElementsAsArray(Def);
    Fail('call to appendElementsAsArray should have raise exception');
  except
    on E : Exception do Check(pos('not supported', E.Message) > 0, 'appendElementsAsArray should have raised exception. error: ' + E.Message);
  end;

  SetLength(Def, 0);
  try
    FIBsonBuffer.appendElementsAsArray(Def);
    Fail('call to appendElementsAsArray should have raise exception');
  except
    on E : Exception do Check(pos('even amount', E.Message) > 0, 'appendElementsAsArray should have raised exception. error: ' + E.Message);
  end;
end;

procedure TestIBsonBuffer.TestAppendStr_n;
var
  ReturnValue: Boolean;
  Value: UTF8String;
  Name: UTF8String;
  b : IBson;
begin
  Name := 'STRFLD';
  Value := 'STRVAL';
  ReturnValue := FIBsonBuffer.AppendStr_n(Name, Value, 3);
  Check(ReturnValue, 'ReturnValue should be True');
  b := FIBsonBuffer.finish;
  CheckEqualsString('STR', b.Value('STRFLD'), 'field on BSon object doesn''t match expected value');
end;

procedure TestIBsonBuffer.TestappendSymbol_n;
var
  ReturnValue: Boolean;
  Value: UTF8String;
  Name: UTF8String;
  b : IBson;
begin
  Name := 'SYMFLD';
  Value := 'SymbolTest';
  ReturnValue := FIBsonBuffer.appendSymbol_n(Name, Value, 3);
  Check(ReturnValue, 'ReturnValue should be True');
  b := FIBsonBuffer.finish;
  CheckEqualsString('Sym', b.Value(Name), 'Symbol value doesn''t match');
end;

procedure TestIBsonBuffer.TeststartObject;
var
  ReturnValue: Boolean;
  Name: UTF8String;
  b : IBson;
  it : IBsonIterator;
begin
  Name := 'OBJ';
  ReturnValue := FIBsonBuffer.startObject(Name);
  Check(ReturnValue, 'ReturnValue should be True');
  Check(FIBsonBuffer.AppendStr('STRFLD', 'STRVAL'), 'Call to AppendStr should return true');
  Check(FIBsonBuffer.Append('INTFLD', 1), 'Call to Append should return true');
  Check(FIBsonBuffer.finishObject, 'Call to FIBsonBuffer.finishObjects should return true');
  b := FIBsonBuffer.finish;
  it := b.iterator;
  Check(it <> nil, 'Call to subiterator should be  <> nil');
  it.Next;
  it := it.subiterator;
  Check(it <> nil, 'Call to subiterator should be  <> nil');
  it.Next;
  CheckEqualsString('STRVAL', it.Value, 'STRFLD should be equals to STRVAL');
  it.Next;
  CheckEquals(1, it.Value, 'INTFLD should be equals to 1');
end;

procedure TestIBsonBuffer.TeststartArray;
var
  ReturnValue: Boolean;
  Name: UTF8String;
  b : IBson;
  it : IBsonIterator;
  Arr : TIntegerArray;
begin
  Name := 'ARR';
  ReturnValue := FIBsonBuffer.startArray(Name);
  Check(ReturnValue, 'ReturnValue should be True');
    Check(FIBsonBuffer.Append('0', 10), 'Call to Append should return True');
    Check(FIBsonBuffer.Append('0', 20), 'Call to Append should return True');
    Check(FIBsonBuffer.Append('0', 30), 'Call to Append should return True');
  FIBsonBuffer.finishObject;
  b := FIBsonBuffer.finish;
  it := b.iterator;
  it.Next;
  Arr := it.getIntegerArray;
  CheckEquals(3, length(Arr), 'Array should contain three elements');
  CheckEquals(10, Arr[0], 'First element of array should be equals to 10');
  CheckEquals(20, Arr[1], 'First element of array should be equals to 20');
  CheckEquals(30, Arr[2], 'First element of array should be equals to 30');
end;

procedure TestIBsonBuffer.Testsize;
var
  InitialSize : Integer;
  ReturnValue: Integer;
begin
  InitialSize := FIBsonBuffer.size;
  CheckNotEquals(0, InitialSize, 'Initial value of Bson buffer should be different from zero');
  FIBsonBuffer.AppendStr('STR', 'VAL');
  ReturnValue := FIBsonBuffer.size;
  Check(ReturnValue > InitialSize, 'After inserting an element on Bson buffer size should be larger than initial size');
end;

{ TestIBsonIterator }

type
  PBinData = ^TBinData;
  TBinData = array [0..15] of Byte;

const
  ABinData : TBinData = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);

procedure TestIBsonIterator.SetUp;
var
  Buf : IBsonBuffer;
  i : integer;
begin
  Buf := NewBsonBuffer;
  Buf.AppendStr('STR', 'STRVAL');
  Buf.Append('INT', 1);
  Buf.Append('INT64', Int64(10));
  Buf.appendBinary('BIN', 0, @ABinData, sizeof(ABinData));
  SetLength(BoolArr, 2);
  BoolArr[0] := False;
  BoolArr[1] := True;
  Buf.appendArray('BOOLARR', BoolArr);
  Buf.appendCode('CODE', '123456');
  SetLength(DblArr, 5);
  for I := low(DblArr) to high(DblArr) do
    DblArr[i] := i + 0.5;
  Buf.appendArray('DBLARR', DblArr);
  SetLength(IntArr, 5);
  for i := low(IntArr) to high(IntArr) do
    IntArr[i] := i;
  Buf.appendArray('INTARR', IntArr);
  BsonOID := NewBsonOID;
  Buf.Append('BSONOID', BsonOID);
  BsonRegEx := NewBsonRegEx('123', '456');
  Buf.Append('BSONREGEX', BsonRegEx);
  SetLength(StrArr, 5);
  for I := low(StrArr) to high(StrArr) do
    StrArr[i] := IntToStr(i);
  Buf.appendArray('STRARR', StrArr);
  FTimeStamp := NewBsonTimestamp(Now, 0);
  Buf.append('TS', FTimeStamp);
  bb := BSON(['SUBINT', 123]);
  Buf.Append('SUBOBJ', bb);
  b := Buf.finish;
  FIBsonIterator := b.iterator;
  FIBsonIterator.Next;
end;

procedure TestIBsonIterator.TearDown;
begin
  FIBsonIterator := nil;
  b := nil;
  bb := nil;
  BsonOID := nil;
  BsonRegEx := nil;
  FTimestamp := nil;
  inherited;
end;

procedure TestIBsonIterator.TestGetAsInt64;
var
  ReturnValue: Int64;
  i : integer;
begin
  for i := 1 to 2 do
    FIBsonIterator.Next;
  ReturnValue := FIBsonIterator.GetAsInt64;
  CheckEquals(10, ReturnValue, 'Call to GetAsInt64 should return 10');
end;

procedure TestIBsonIterator.TestgetHandle;
var
  ReturnValue: Pointer;
begin
  ReturnValue := FIBsonIterator.getHandle;
  CheckNotEquals(0, integer(ReturnValue), 'Call to FIBsonIterator.getHandle should return value <> nil');
end;

procedure TestIBsonIterator.TestgetBinary;
var
  ReturnValue: IBsonBinary;
  i : integer;
begin
  for i := 1 to 3 do
    FIBsonIterator.Next;
  ReturnValue := FIBsonIterator.getBinary;
  for i := low(ABinData) to high(ABinData) do
    CheckEquals(ABinData[i], PBinData(ReturnValue.getData)^[i], 'Binary data doesn''t match');
end;

procedure TestIBsonIterator.TestgetBooleanArray;
var
  ReturnValue: TBooleanArray;
  i : integer;
begin
  for i := 1 to 4 do
    FIBsonIterator.Next;
  ReturnValue := FIBsonIterator.getBooleanArray;
  CheckEquals(length(BoolArr), length(ReturnValue), 'Boolean array size doesn''t match');
  CheckEquals(BoolArr[0], ReturnValue[0], 'First element of boolean array doesn''t match');
  CheckEquals(BoolArr[1], ReturnValue[1], 'First element of boolean array doesn''t match');
end;

procedure TestIBsonIterator.TestgetCodeWScope;
var
  ReturnValue: IBsonCodeWScope;
  i : integer;
begin
  for i := 1 to 5 do
    FIBsonIterator.Next;
  ReturnValue := FIBsonIterator.getCodeWScope;
  Check(ReturnValue <> nil, 'BsonCodeWScope object should be <> nil');
  CheckEqualsString('123456', ReturnValue.getCode, 'Code doesn''t match');
end;

procedure TestIBsonIterator.TestgetDoubleArray;
var
  ReturnValue: TDoubleArray;
  i : integer;
begin
  for i := 1 to 6 do
    FIBsonIterator.Next;
  ReturnValue := FIBsonIterator.getDoubleArray;
  for i := low(DblArr) to high(DblArr) do
    CheckEquals(DblArr[i], ReturnValue[i], 'Double array element doesn''t match');
end;

procedure TestIBsonIterator.TestgetIntegerArray;
var
  ReturnValue : TIntegerArray;
  i : integer;
begin
  for i := 1 to 7 do
    FIBsonIterator.Next;
  ReturnValue := FIBsonIterator.getIntegerArray;
  for i := low(IntArr) to high(IntArr) do
    CheckEquals(IntArr[i], ReturnValue[i], 'Integer array element doesn''t match');
end;

procedure TestIBsonIterator.TestgetOID;
var
  ReturnValue: IBsonOID;
  i : integer;
begin
  for i := 1 to 8 do
    FIBsonIterator.Next;
  ReturnValue := FIBsonIterator.getOID;
  CheckEqualsString(BsonOID.AsString, ReturnValue.AsString, 'BsonOID doesn''t match');
end;

procedure TestIBsonIterator.TestgetRegex;
var
  ReturnValue: IBsonRegex;
  i : integer;
begin
  for i := 1 to 9 do
    FIBsonIterator.Next;
  ReturnValue := FIBsonIterator.getRegex;
  CheckEqualsString(BsonRegEx.getPattern, ReturnValue.getPattern, 'Pattern of RegEx doesn''t match');
  CheckEqualsString(BsonRegEx.getOptions, ReturnValue.getOptions, 'Options of RegEx doesn''t match');
end;

procedure TestIBsonIterator.TestgetStringArray;
var
  ReturnValue: TStringArray;
  i : integer;
begin
  for i := 1 to 10 do
    FIBsonIterator.Next;
  ReturnValue := FIBsonIterator.getStringArray;
  for i := low(StrArr) to high(StrArr) do
    CheckEqualsString(StrArr[i], ReturnValue[i], 'UTF8String array element doesn''t match');
end;

procedure TestIBsonIterator.TestgetTimestamp;
var
  ReturnValue: IBsonTimestamp;
  i : integer;
begin
  for i := 1 to 11 do
    FIBsonIterator.Next;
  ReturnValue := FIBsonIterator.getTimestamp;
  CheckEquals(FTimeStamp.getTime, ReturnValue.getTime, DELTA_DATE, 'Timestamp date field doesn''t match');
  CheckEquals(FTimeStamp.getIncrement, ReturnValue.getIncrement, 'Timestamp increment field doesn''t match');
end;

procedure TestIBsonIterator.Testkey;
var
  ReturnValue: UTF8String;
  i : integer;
begin
  ReturnValue := FIBsonIterator.key;
  CheckEqualsString('STR', ReturnValue, 'Key of first iterator element should be equals to STR');
  for i := 1 to 11 do
    FIBsonIterator.Next;
  ReturnValue := FIBsonIterator.key;    
  CheckEqualsString('TS', ReturnValue, 'Key of last iterator element should be equals to TS');
end;

procedure TestIBsonIterator.TestKind;
var
  ReturnValue: TBsonType;
begin
  ReturnValue := FIBsonIterator.Kind;
  CheckEquals(integer(bsonSTRING), integer(ReturnValue), 'First element returned by iterator should be bsonSTRING');
  FIBsonIterator.Next;
  ReturnValue := FIBsonIterator.Kind;
  CheckEquals(integer(bsonINT), integer(ReturnValue), 'Second element returned by iterator should be bsonINT');
  FIBsonIterator.Next;
  ReturnValue := FIBsonIterator.Kind;
  CheckEquals(integer(bsonLONG), integer(ReturnValue), 'Third element returned by iterator should be bsonLONG');
end;

procedure TestIBsonIterator.TestTryToReadPastEnd;
var
  ReturnValue: TBsonType;
begin
  ReturnValue := FIBsonIterator.Kind;
  CheckEquals(integer(bsonSTRING), integer(ReturnValue), 'First element returned by iterator should be bsonSTRING');
  FIBsonIterator.Next;
  ReturnValue := FIBsonIterator.Kind;
  CheckEquals(integer(bsonINT), integer(ReturnValue), 'Second element returned by iterator should be bsonINT');
  FIBsonIterator.Next;
  ReturnValue := FIBsonIterator.Kind;
  CheckEquals(integer(bsonLONG), integer(ReturnValue), 'Third element returned by iterator should be bsonLONG');

  while FIBsonIterator.Next do;
  // Here we are not past end of the iterator, attempt to read Kind should return on Exception
  try
    FIBsonIterator.Kind;
    Fail('Call to Kind when past end of iterator should result on error');
  except
    on E : Exception do if pos('Iterator at end', E.Message) <= 0 then raise;
  end;
end;

procedure TestIBsonIterator.Testsubiterator;
var
  ReturnValue: IBsonIterator;
  i : integer;
begin
  for i := 1 to 12 do
    FIBsonIterator.Next;
  ReturnValue := FIBsonIterator.subiterator;
  Check(ReturnValue <> nil, 'FIBsonIterator.subiterator should be different from nil');
  ReturnValue.Next;
  CheckEquals(123, integer(ReturnValue.Value), 'Value of subiterator should be equals to 123');
end;

procedure TestIBsonIterator.TestValue;
var
  ReturnValue: Variant;
begin
  ReturnValue := FIBsonIterator.Value;
  CheckEqualsString('STRVAL', ReturnValue, 'ReturnValue should be equals to STRVAL');
end;

{ TestIBson }

procedure TestIBson.SetUp;
begin
  FIBson := BSON(['ID', 123, 'S', 'STR']);
end;

procedure TestIBson.TearDown;
begin
  FIBson := nil;
  inherited;
end;

procedure TestIBson.Testfind;
var
  ReturnValue: IBsonIterator;
  Name: UTF8String;
begin
  Name := 'S';
  ReturnValue := FIBson.find(Name);
  Check(ReturnValue <> nil, 'Call to FIBson.Find should have returned an iterator');
  CheckEqualsString('STR', ReturnValue.Value, 'Iterator.Value should have returned STR');
end;

procedure TestIBson.TestgetHandle;
var
  ReturnValue: Pointer;
begin
  ReturnValue := FIBson.getHandle;
  Check(ReturnValue <> nil, 'Call to FIBson.getHandle should return value <> nil');
end;

procedure TestIBson.Testiterator;
var
  ReturnValue: IBsonIterator;
begin
  ReturnValue := FIBson.iterator;
  Check(ReturnValue <> nil, 'Call to get Bson iterator should have returned value <> nil');
  ReturnValue.Next;
  CheckEquals(123, ReturnValue.Value, 'Initial value of iterator is 123');
end;

procedure TestIBson.TestNewBsonCopy;
var
  ACopy : IBson;
begin
  ACopy := NewBsonCopy(FIBson.Handle);
  CheckEquals(123, ACopy.find('ID').value);
  CheckEqualsString('STR', ACopy.find('S').value);
end;

procedure TestIBson.Testsize;
var
  ReturnValue: Integer;
begin
  ReturnValue := FIBson.size;
  CheckNotEquals(0, ReturnValue, 'Call to FIBson.Size should return value <> zero');
end;

procedure TestIBson.TestValue;
var
  ReturnValue: Variant;
  Name: UTF8String;
begin
  Name := 'ID';
  ReturnValue := FIBson.Value(Name);
  CheckEquals(123, ReturnValue, 'ReturnValue should be equals to 123');
end;

var
  CustomReturnIntCalled : Boolean;
  CustomOIDFuzz : Boolean;

function CustomOIDReturnIntFunction: Integer; cdecl;
begin
  Result := 0;
  CustomReturnIntCalled := True;
end;

function CustomOIDFuzzFunction: Integer; cdecl;
begin
  Result := 0;
  CustomOIDFuzz := True;
end;

procedure TestBsonAPI.Test_bson_set_oid_inc;
begin
  Check(CustomReturnIntCalled, 'CustomSetOIDIncCalled should be true after creating BsonOID');
end;

procedure TestBsonAPI.Test_bson_set_oid_fuzz;
begin
  Check(CustomOIDFuzz, 'CustomSetOIDIncCalled should be true after creating BsonOID');
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestIBsonOID.Suite);
  RegisterTest(TestIBsonCodeWScope.Suite);
  RegisterTest(TestIBsonRegex.Suite);
  RegisterTest(TestIBsonTimestamp.Suite);
  RegisterTest(TestIBsonBinary.Suite);
  RegisterTest(TestIBsonBuffer.Suite);
  RegisterTest(TestIBsonIterator.Suite);
  RegisterTest(TestBsonAPI.Suite);
  RegisterTest(TestIBson.Suite);
  {$IFDEF OnDemandMongoCLoad}
  InitMongoDBLibrary;
  {$ENDIF}
  bson_set_oid_fuzz(@CustomOIDFuzzFunction);
  bson_set_oid_inc(@CustomOIDReturnIntFunction);
  try
    NewBsonOID;
  finally
    bson_set_oid_fuzz(nil);
    bson_set_oid_inc(nil);
  end;
end.

