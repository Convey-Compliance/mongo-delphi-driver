unit TestMongoStream;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, Classes, MongoStream, MongoDB, GridFS, TestMongoDB, TestGridFS;

{$I MongoC_defines.inc}

type
  // Test methods for class TMongoStream

  TestTMongoStream = class(TestGridFSBase)
  private
    FMongoStream: TMongoStream;
    procedure CheckMongoStreamPointer;
    procedure CreateTestFile;
    {$IFDEF DELPHI2007}
    procedure TestSeek_Int64(AOrigin: TSeekOrigin; AOffset, AbsExpected: Int64);
    {$ENDIF}
    procedure TestSeek_Int32(AOrigin: Word; AOffset: Longint; AbsExpected: Int64);
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestGetSizeIn32;
    procedure TestSetSizeInt32;
    {$IFDEF DELPHI2007}
    procedure TestSetSizeInt64;
    {$ENDIF}
    procedure TestCreateStream;
    procedure TestCreateStreamAndOpenWithDifferentCase;
    procedure TestCreateStreamWithPrefix;
    procedure TestRead;
    procedure TestSeekFromCurrentInt32;
    procedure TestSeekFromEndInt32;
    procedure TestSeekFromBeginningInt32;
    {$IFDEF DELPHI2007}
    procedure TestSeekFromBeginningInt64;
    procedure TestSeekFromCurrentInt64;
    procedure TestSeekFromEndInt64;
    {$ENDIF}
    procedure TestSeekPastTheEndOfFile;
    procedure TestStreamStatusFlag;
    procedure TestStressWriteReads;
    procedure TestWrite;
  end;

implementation

uses
  uFileManagement, FileCtrl, SysUtils, MongoBson;

const
  FILESIZE = 512 * 1024;
  SMALLER_SIZE = 1024;
  FEW_BYTES_OF_DATA : AnsiString = 'this is just a few bytes of data';

procedure TestTMongoStream.CheckMongoStreamPointer;
begin
  Check(FMongoStream <> nil, 'FMongoStream should be <> nil');
end;

procedure TestTMongoStream.CreateTestFile;
begin
  FMongoStream := TMongoStream.Create(FMongo, FSDB, StandardRemoteFileName, [msmWrite, msmCreate], True);
end;

procedure TestTMongoStream.SetUp;
begin
  inherited;
end;

procedure TestTMongoStream.TearDown;
begin
  if FMongoStream <> nil then
    begin
      FMongoStream.Free;
      FMongoStream := nil;
    end;
  inherited;
end;

procedure TestTMongoStream.TestGetSizeIn32;
var
  ReturnValue: Int64;
begin
  CreateTestFile;
  CheckMongoStreamPointer;
  FMongoStream.Write(PAnsiChar(FEW_BYTES_OF_DATA)^, length(FEW_BYTES_OF_DATA));
  ReturnValue := FMongoStream.Size;
  CheckEquals(length(FEW_BYTES_OF_DATA), ReturnValue, 'Expected file size doesn''t match');
end;

procedure TestTMongoStream.TestSetSizeInt32;
var
  NewSize: Integer;
begin
  CreateTestFile;
  CheckMongoStreamPointer;
  FMongoStream.Write(PAnsiChar(FEW_BYTES_OF_DATA)^, length(FEW_BYTES_OF_DATA));
  NewSize := length(FEW_BYTES_OF_DATA) - 2;
  FMongoStream.Size := NewSize;
  CheckEquals(NewSize, FMongoStream.Position, 'Position should be at the end of the file');
  FreeAndNil(FMongoStream);
  FMongoStream := TMongoStream.Create(FMongo, FSDB, StandardRemoteFileName, [], True);
  CheckEquals(NewSize, FMongoStream.Size, 'New size was not taken by MongoStream');
end;

{$IFDEF DELPHI2007}
procedure TestTMongoStream.TestSetSizeInt64;
var
  NewSize: Int64;
begin
  CreateTestFile;
  CheckMongoStreamPointer;
  FMongoStream.Write(PAnsiChar(FEW_BYTES_OF_DATA)^, length(FEW_BYTES_OF_DATA));
  NewSize := length(FEW_BYTES_OF_DATA) - 2;
  FMongoStream.Size := NewSize;
  CheckEquals(NewSize, FMongoStream.Position, 'Position should be at the end of the file');
  FreeAndNil(FMongoStream);
  FMongoStream := TMongoStream.Create(FMongo, FSDB, StandardRemoteFileName, [], True);
  CheckEquals(NewSize, FMongoStream.Size, 'New size was not taken by MongoStream');
end;
{$ENDIF}

procedure TestTMongoStream.TestCreateStream;
var
  AFileName: AnsiString;
  ADB: AnsiString;
begin
  ADB := FSDB;
  AFileName := StandardRemoteFileName;
  FMongoStream := TMongoStream.Create(FMongo, ADB, AFileName, [msmCreate, msmWrite], False);
  CheckMongoStreamPointer;
end;

procedure TestTMongoStream.TestCreateStreamAndOpenWithDifferentCase;
var
  AFileName: AnsiString;
  ADB: AnsiString;
begin
  ADB := FSDB;
  AFileName := StandardRemoteFileName;
  FMongoStream := TMongoStream.Create(FMongo, ADB, AFileName, [msmCreate, msmWrite], False);
  CheckMongoStreamPointer;
  FreeAndNil(FMongoStream);
  FMongoStream := TMongoStream.Create(FMongo, ADB, AnsiString(LowerCase(AFileName)), [], False);
end;

procedure TestTMongoStream.TestCreateStreamWithPrefix;
var
  AFileName: AnsiString;
  APrefix: AnsiString;
  ADB: AnsiString;
begin
  ADB := FSDB;
  AFileName := StandardRemoteFileName;
  APrefix := 'prefix_test';
  FMongoStream := TMongoStream.Create(FMongo, ADB, AFileName, APrefix, [msmCreate], True, False);
  CheckMongoStreamPointer;
end;

procedure TestTMongoStream.TestRead;
var
  ReturnValue: Integer;
  Count: Integer;
  Buffer: array [0..SMALLER_SIZE - 1] of AnsiChar;
begin
  CreateTestFile;
  CheckMongoStreamPointer;
  Count := length(FEW_BYTES_OF_DATA);
  FMongoStream.Write(PAnsiChar(FEW_BYTES_OF_DATA)^, Count);
  FMongoStream.Position := 0;
  ReturnValue := FMongoStream.Read(Buffer, Count);
  CheckEquals(Count, ReturnValue, 'Number of bytes read dont''t match');
  Check(CompareMem(@Buffer, PAnsiChar(FEW_BYTES_OF_DATA), Count), 'Memory read don''t match data written');
end;

procedure TestTMongoStream.TestSeekFromCurrentInt32;
begin
  TestSeek_Int32(soFromCurrent, -1, length(FEW_BYTES_OF_DATA) - 1);
end;

procedure TestTMongoStream.TestSeekFromEndInt32;
begin
   TestSeek_Int32(soFromEnd, -2, length(FEW_BYTES_OF_DATA) - 2);
end;

procedure TestTMongoStream.TestSeekFromBeginningInt32;
begin
  TestSeek_Int32(soFromBeginning, 5, 5);
end;

procedure TestTMongoStream.TestSeek_Int32(AOrigin: Word; AOffset: Longint;
    AbsExpected: Int64);
var
  ReturnValue: Integer;
  Origin: Word;
  Offset: Integer;
  Buffer: array [0..SMALLER_SIZE - 1] of AnsiChar;
  Count : integer;
begin
  CreateTestFile;
  CheckMongoStreamPointer;
  Count := length(FEW_BYTES_OF_DATA);
  FMongoStream.Write(PAnsiChar(FEW_BYTES_OF_DATA)^, Count);
  Offset := AOffset;
  Origin := AOrigin;
  ReturnValue := FMongoStream.Seek(Offset, Origin);
  CheckEquals(AbsExpected, ReturnValue, 'Return value from Seek not what expected');
  CheckEquals(Count - AbsExpected, FMongoStream.Read(Buffer, Count), 'Number of bytes read after first Seek not what expected');
  Check(CompareMem(@Buffer, @PAnsiChar(FEW_BYTES_OF_DATA)[AbsExpected], Count - AbsExpected), 'Data read doesn''t match');
end;

{$IFDEF DELPHI2007}
procedure TestTMongoStream.TestSeekFromBeginningInt64;
begin
  TestSeek_Int64(soBeginning, 5, 5);
end;

procedure TestTMongoStream.TestSeekFromCurrentInt64;
begin
  TestSeek_Int64(soCurrent, -1, length(FEW_BYTES_OF_DATA) - 1);
end;

procedure TestTMongoStream.TestSeekFromEndInt64;
begin
  TestSeek_Int64(soEnd, -2, length(FEW_BYTES_OF_DATA) - 2);
end;
{$ENDIF}

procedure TestTMongoStream.TestSeekPastTheEndOfFile;
begin
  CreateTestFile;
  CheckMongoStreamPointer;
  CheckEquals(length(FEW_BYTES_OF_DATA), FMongoStream.Write(PAnsiChar(FEW_BYTES_OF_DATA)^, length(FEW_BYTES_OF_DATA)), 'Write didn''t return that I wrote the same amount of bytes written');
  CheckEquals(length(FEW_BYTES_OF_DATA), FMongoStream.Seek(length(FEW_BYTES_OF_DATA) + 1, {$IFDEF DELPHI2007} soBeginning {$ELSE} soFromBeginning {$ENDIF}), 'Should not allow seeking past the end of file');
  CheckEquals(length(FEW_BYTES_OF_DATA), FMongoStream.Position, 'Should not allow seeking past the end of file');
end;

{$IFDEF DELPHI2007}
procedure TestTMongoStream.TestSeek_Int64(AOrigin: TSeekOrigin; AOffset,
    AbsExpected: Int64);
var
  ReturnValue: Int64;
  Origin: TSeekOrigin;
  Offset: Int64;
  Buffer: array [0..SMALLER_SIZE - 1] of AnsiChar;
  Count : integer;
begin
  CreateTestFile;
  CheckMongoStreamPointer;
  Count := length(FEW_BYTES_OF_DATA);
  FMongoStream.Write(PAnsiChar(FEW_BYTES_OF_DATA)^, Count);
  Offset := AOffset;
  Origin := AOrigin;
  ReturnValue := FMongoStream.Seek(Offset, Origin);
  CheckEquals(AbsExpected, ReturnValue, 'Return value from Seek not what expected');
  CheckEquals(Count - AbsExpected, FMongoStream.Read(Buffer, Count), 'Number of bytes read after first Seek not what expected');
  Check(CompareMem(@Buffer, @PAnsiChar(FEW_BYTES_OF_DATA)[AbsExpected], Count - AbsExpected), 'Data read doesn''t match');
end;
{$ENDIF}

procedure TestTMongoStream.TestStreamStatusFlag;
var
  q : IBson;
  fileid : IBsonOID;
  buf : IBsonBuffer;
begin
  CreateTestFile;
  CheckMongoStreamPointer;
  CheckEquals(length(FEW_BYTES_OF_DATA), FMongoStream.Write(PAnsiChar(FEW_BYTES_OF_DATA)^, length(FEW_BYTES_OF_DATA)), 'Write didn''t return that I wrote the same amount of bytes written');
  fileid := FMongoStream.ID;
  FreeAndNil(FMongoStream);
  FMongoStream := TMongoStream.Create(FMongo, FSDB, StandardRemoteFileName, [], False);
  Check(FMongoStream.Status = mssOk, 'Status of file should report OK status');
  FreeAndNil(FMongoStream);
  buf := NewBsonBuffer;
  buf.Append(PAnsiChar('files_id'), fileid);
  q := buf.finish;
  FMongo.remove('fsdb.fs.chunks', q);
  FMongoStream := TMongoStream.Create(FMongo, FSDB, StandardRemoteFileName, [], False);
  Check(FMongoStream.Status = mssMissingChunks, 'Status of file should report missing chunks');
end;

procedure TestTMongoStream.TestStressWriteReads;
const
  RE_WRITE_POS : array [0..5] of integer = (1024, 1024 * 128, 523, 1024 * 256 + 33, 0, 1024 * 100 + 65);
  RE_WRITE_LEN : array [0..5] of integer = ( 512, 1024 * 300, 1024 * 128, 45, 1024 * 64 + 5, 1024 * 313);
var
  Buffer : PAnsiChar;
  i, j : integer;
  ReadBuf : PAnsiChar;
begin
  CreateTestFile;
  CheckMongoStreamPointer;
  GetMem(Buffer, FILESIZE);
  try
    GetMem(ReadBuf, FILESIZE);
    try
      for i := 0 to FILESIZE - 1 do
        Buffer[i] := AnsiChar(Random(256));
      CheckEquals(FILESIZE, FMongoStream.Write(Buffer^, FILESIZE), 'Call to Write should have written all data requested');
      FreeAndNil(FMongoStream);
      FMongoStream := TMongoStream.Create(FMongo, FSDB, StandardRemoteFileName, [msmWrite], True); // Reopen the file
      Check(FMongoStream.Status = mssOk, 'Status of file should be mssOk');
      for i := Low(RE_WRITE_POS) to High(RE_WRITE_POS) do
        begin
          FMongoStream.Position := RE_WRITE_POS[i];
          for j := RE_WRITE_POS[i] to RE_WRITE_POS[i] + RE_WRITE_LEN[i] do
            Buffer[j] := AnsiChar(Random(256));
          CheckEquals(RE_WRITE_LEN[i], FMongoStream.Write(Buffer[RE_WRITE_POS[i]], RE_WRITE_LEN[i]), 'Amount of data overriden don''t match count');
          FMongoStream.Position := RE_WRITE_POS[i];
          CheckEquals(RE_WRITE_LEN[i], FMongoStream.Read(ReadBuf^, RE_WRITE_LEN[i]), 'Amount of data read after overriding don''t match');
          Check(CompareMem(@Buffer[RE_WRITE_POS[i]], ReadBuf, RE_WRITE_LEN[i]), 'Data read from stream don''t match data written');
        end;
    finally
      FreeMem(ReadBuf);
    end;
  finally
    FreeMem(Buffer);
  end;
end;

procedure TestTMongoStream.TestWrite;
var
  ReturnValue: Integer;
  Count: Integer;
  Buffer: Pointer;
begin
  CreateTestFile;
  CheckMongoStreamPointer;
  Count := length(FEW_BYTES_OF_DATA);
  Buffer := PAnsiChar(FEW_BYTES_OF_DATA);
  ReturnValue := FMongoStream.Write(Buffer, Count);
  CheckEquals(Count, ReturnValue, 'Write didn''t return that I wrote the same amount of bytes written');
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTMongoStream.Suite);
end.

